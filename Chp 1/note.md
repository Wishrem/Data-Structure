# Chp 1 基本概念

## 关于数据结构

### 定义

*这里选取了本人最喜欢的定义（个人的结论都会用斜体标注，下同）*

***数据结构是ADT（Abstract Data Type）的物理实现***

> *Clifford A.Shaffer, 《数据结构与算法分析》*

数据结构和算法是有区别的，但可能你难以区分，这里不提算法，算法内容详见[《算法设计与分析》]()「待更新」。

***数据结构对空间进行结构上的分配，使问题解决更有效率。***

**解决问题方法的效率，跟数据的组织方式有关**（老师的结论将会用粗体标注，下同）

比如图书馆，我想要查找《数据结构与算法分析》，假设图书馆的书是乱序，也就是随机摆放，那我就需要每一本书都找过去，因为我不知道《数据结构与算法分析》是否会是下一本。好在现实中的图书馆并不如此，我可以先从大类筛选，比方该书位于“计算机类”在4层，然后再根据书的名称或者对应编码确定更小的分区，比如拼音以“S”开头的书位于西南侧书架。一顿操作下来，我需要检索的量就有巨量的减小，使问题解决更有效率，这就是数据结构的现实案例。

## 关于空间使用

### 样例1：

写程序实现一个函数printN，使得传入一个正整数位N的参数后，能顺序打印从1到N的全部正整数。

两个不同的实现，一个用循环实现，另一个用递归实现，比较两者的耗时。

具体代码详见printN.cpp（乱码请将编码换成UTF-8），使用指令：

```bash
g++ printN.cpp -o printN.out
./printN.out [n的值]
# 值尽量大一些，n=10000时只有0.2ms差距，太大会爆内存
```

你可以发现两个实现的运行时间的差距。

**解决问题方法的效率，跟空间的利用率有关**

解释一下，实现递归操作的时候，系统需要维护一个栈，需要把待运行的代码压入这个栈中，但递归终止条件到来时，将逐个从栈中弹出还未运行的代码。

所以在空间利用率上来看，递归相比于循环，多了一个需要维护的空间，实际上可以通过算法来省去，提高空间利用率。

## 关于算法效率*（可忽略）*

### 样例2:

写程序计算给定多项式在给定点$x$处的值，多项式为$f(x)=a_0+a_1x+\dots+a_{n-1}x^{n-1}+a_nx^n$

两个不同的实现，一个用朴素写法实现，另一个用优化算法实现，比较两者的耗时。

具体代码详见f.cpp（乱码请将编码换成UTF-8），使用指令：

```bash
g++ f.cpp -o f.out
./f.out [n的值] [x的值]
# ai的值是0-9的随机整数，n=100,000差距只有0.2ms
```

你可以发现两个实现的运行时间的差距。

**解决问题方法的效率，跟算法的巧妙程度有关**

可以发现，这个样例和样例1也是算法上的差距，递归属于一种算法，~~个人感觉是样例没选好，但鄙人也想不出有什么好的例子了~~。

这两种方法的区别就是计算的次数，还有硬件底层对于pow（求幂）没有很好的适配，导致效率低下。*严格意义上而言不能算是数据结构带来的好处*

## 抽象数据类型

### 什么是数据结构

- **==数据对象==在计算机中的组织方式**

  - **逻辑结构**

  - **物理存储结构**

  这里需要合在一起说会容易区分：

  假设你需要设计一个集合，在逻辑结构中这就是一个集合，也就是没有重复元素，你只需要保证这个特性。

  而在物理存储结构，你需要考虑这些集合的元素在内存中的位置（你可以把内存看作是一个有着很多储物柜的集合体），或许你会连续地放在一起，抑或是隔一个储物柜放一个元素。

  *简言之，逻辑结构是在设计，而物理存储结构是在实现。*

*以下可略，下文有提到什么是算法*

- **数据对象必定与一系列加在其上的==操作==相关联**
- **完成这些操作所用的方法就是==算法==**

### 描述数据结构的方法

**抽象数据类型ADT（Abstract Data Type）**

- **数据类型**
  - **数据对象集**
  - **数据集合相关联的操作集**
- **抽象：描述数据类型的方法不依赖于具体实现**
  - **与存放数据的机器无关**
  - **与数据存储的物理结构无关**
  - **与实现操作的算法和编程语言均无关**

**只描述数据对象集和相关操作集“==是什么==”，并不涉及“==如何做到==”的问题**

一个很好的例子是C++中的vector类，你可以尽情的调用它所提供的操作，但不用考虑其中的实现。

## 什么是算法

### 定义

- 一个有限指令集
- 接受一些输入（有些情况下不需要输入）
- 产生输出
- 一定在有限步骤之后终止
- 每一条指令必须
  - 有充分明确的目标，不可以有奇异
  - 计算机能处理的范围之内
  - 描述应不依赖于任何一种计算机语言以及具体的实现手段（即抽象，见下面这个代码段）

```c++
void SelectionSort ( int List[], int N)
{ /* 将N个整数List[0]...List[N-1]进行非递减排序 */
  for (i = 0; i < N; i ++ ) {
    从List[i]到List[N-1]中找最小元，并将其位置复制给MinPosition‘
    将为排序不分的最小元换到有序部分的最后位置；
  }
}
```

这个适用于任何语言，只是看起来像C/C++，其中的指令（中文部分，严格意义上for部分也算，但这里特指中文描述部分）可以用任何语言的特性实现。

*这个就是抽象，只负责设计，不需要探究怎么实现。*

## 什么是好的算法

- **空间复杂度$S(n)$：占用存储单元的长度**
- **时间复杂度$T(n)$：耗费时间的长度**

*这两个指标越小，就越好*

**在分析一般算法效率时，我们经常关注下面两种复杂度（S同理）**

- **最坏情况复杂度$T_{worst}(n)$**
- **平均复杂度$T_{avg}(n)$**

$T_{avg}(n)\le T_{worst}(n)$

通常情况下平均复杂度计算较难，所以最关心的是最坏情况下的复杂度，关系这个复杂度也更有现实意义。

## 复杂度的渐进表示法

这里只写了T，S同理

- **上界：$T(n)=O(f(n))$表示存在常数$C>0,n_0>0$使得当$n\ge n_0$时有$T(n)\le C\cdot f(n)$**

- **下界：$T(n)=\Omega(g(n))$表示存在常数$C>0,n_0>0$使得当$n\ge n_0$时有$T(n)\ge C\cdot g(n)$**

- **真实：$T(n)=\Theta(h (n))$表示同时有$T(n)= O(h(n))$和$T(n)=\Omega(h(n))$**

分析算法效率时，应该取最小上界和最大下界才有实际意义，*通常我们使用$O(f(n))$*

关于n的规模递增函数（n充分大的时候）：

$1\ll logn\ll n\ll nlogn\ll n^2\ll n^3\ll 2^n\ll n!$
